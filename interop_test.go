package lzo1z

// interop_test.go - Tests that verify Go decompressor against C-compressed data.
//
// The Go compressor only emits a subset of valid LZO1Z opcodes. The C lzo1z-999
// compressor uses the full opcode space (M1a, M1b, M2 offset reuse, M2 lengths
// 5-8, trailing literal encoding, M4 large offsets). These tests verify the Go
// decompressor correctly handles ALL opcodes by decompressing data produced by
// the real liblzo2 C library.
//
// Test vectors are generated by testdata/gen/gen_vectors.c using liblzo2 2.10.
// Regenerate: cd testdata/gen && docker build -t lzo1z-gen . && docker run --rm lzo1z-gen > ../../interop_vectors_test.go

import (
	"bytes"
	"errors"
	"testing"
)

func TestDecompressCInterop(t *testing.T) {
	for _, tc := range interopTestCases {
		t.Run(tc.name, func(t *testing.T) {
			if tc.inputLen == 0 {
				return // skip empty
			}

			// Decompress the C-compressed data
			out := make([]byte, tc.inputLen+100)
			n, err := Decompress(tc.compressed, out)
			if err != nil {
				t.Fatalf("Decompress failed: %v", err)
			}

			if n != tc.inputLen {
				t.Fatalf("Decompress returned %d bytes, want %d", n, tc.inputLen)
			}

			if !bytes.Equal(out[:n], tc.input) {
				// Find first difference
				for i := 0; i < n && i < len(tc.input); i++ {
					if out[i] != tc.input[i] {
						t.Fatalf("Mismatch at byte %d: got 0x%02x, want 0x%02x", i, out[i], tc.input[i])
					}
				}
				t.Fatalf("Output length mismatch")
			}
		})
	}
}

func TestDecompressCInteropRoundtrip(t *testing.T) {
	// For each C-compressed vector, verify that our Go compressor can also
	// compress the input and that both the Go-compressed and C-compressed
	// versions decompress to the same output.
	for _, tc := range interopTestCases {
		t.Run(tc.name, func(t *testing.T) {
			if tc.inputLen == 0 {
				return
			}

			// Go compress
			goDst := make([]byte, MaxCompressedSize(tc.inputLen))
			goN, err := Compress(tc.input, goDst)
			if err != nil {
				t.Fatalf("Go Compress failed: %v", err)
			}

			// Decompress Go-compressed
			goOut := make([]byte, tc.inputLen+100)
			goDecompN, err := Decompress(goDst[:goN], goOut)
			if err != nil {
				t.Fatalf("Decompress(Go-compressed) failed: %v", err)
			}

			// Decompress C-compressed
			cOut := make([]byte, tc.inputLen+100)
			cDecompN, err := Decompress(tc.compressed, cOut)
			if err != nil {
				t.Fatalf("Decompress(C-compressed) failed: %v", err)
			}

			// Both should produce identical output
			if !bytes.Equal(goOut[:goDecompN], cOut[:cDecompN]) {
				t.Fatalf("Go-compressed and C-compressed decompress to different output")
			}

			if !bytes.Equal(goOut[:goDecompN], tc.input) {
				t.Fatalf("Decompressed output doesn't match original input")
			}

			// Log compression ratio comparison
			t.Logf("C: %d->%d (%.1f%%), Go: %d->%d (%.1f%%)",
				tc.inputLen, len(tc.compressed), float64(len(tc.compressed))/float64(tc.inputLen)*100,
				tc.inputLen, goN, float64(goN)/float64(tc.inputLen)*100)
		})
	}
}

func TestDecompressInputNotConsumed(t *testing.T) {
	// C's safe decompressor returns LZO_E_INPUT_NOT_CONSUMED when there are
	// extra bytes after the EOF marker (0x11 0x00 0x00). The Go decompressor
	// should do the same to avoid silently masking data corruption.

	// Compress some valid data first
	input := []byte("Hello, World! Hello, World! Hello, World!")
	dst := make([]byte, MaxCompressedSize(len(input)))
	n, err := Compress(input, dst)
	if err != nil {
		t.Fatalf("Compress failed: %v", err)
	}
	compressed := dst[:n]

	// Valid compressed data should decompress fine
	out := make([]byte, len(input)+100)
	_, err = Decompress(compressed, out)
	if err != nil {
		t.Fatalf("Valid data failed: %v", err)
	}

	// Append garbage after EOF marker - should return ErrInputNotConsumed
	tests := []struct {
		name  string
		extra []byte
	}{
		{"one_byte", []byte{0x00}},
		{"two_bytes", []byte{0xAB, 0xCD}},
		{"many_bytes", []byte{0x01, 0x02, 0x03, 0x04, 0x05}},
		{"looks_like_data", []byte{0x11, 0x00, 0x00}}, // another EOF marker
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			withGarbage := make([]byte, len(compressed)+len(tc.extra))
			copy(withGarbage, compressed)
			copy(withGarbage[len(compressed):], tc.extra)

			out := make([]byte, len(input)+100)
			_, err := Decompress(withGarbage, out)
			if !errors.Is(err, ErrInputNotConsumed) {
				t.Errorf("Expected ErrInputNotConsumed, got: %v", err)
			}
		})
	}
}

func TestDecompressDictionaryRejection(t *testing.T) {
	// C supports lzo1z_999_compress_dict which produces data that requires
	// a dictionary to decompress. The Go decompressor does not support
	// dictionary decompression. Dictionary-compressed data will typically
	// fail with ErrLookbehindOverrun because it references data that should
	// be in the dictionary (before the output buffer start).
	//
	// This test documents the behavior: dictionary-compressed data produces
	// an error rather than silently corrupting output.

	// Simulate dict-compressed data: a valid-looking stream that references
	// data at negative offsets (which would be in the dictionary).
	// M3 match: opcode=0x20|1=0x21 (len=3), offset bytes pointing before output start
	dictCompressed := []byte{
		0x15, 0x41, 0x42, 0x43, 0x44, // literal: "ABCD"
		0x21,       // M3: length = 3 (0x20 | 1)
		0xFF, 0xFF, // offset bytes: very large offset (before output start)
		0x11, 0x00, 0x00, // EOF
	}

	out := make([]byte, 1000)
	_, err := Decompress(dictCompressed, out)
	if err == nil {
		t.Error("Expected error for dictionary-like compressed data, got nil")
	}
	// Should be a lookbehind overrun since the match references before output start
	if !errors.Is(err, ErrLookbehindOverrun) {
		t.Logf("Got error (acceptable): %v", err)
	}
}
