package lzo1z

// interop_test.go - Tests that verify Go decompressor against C-compressed data.
//
// The Go compressor only emits a subset of valid LZO1Z opcodes. The C lzo1z-999
// compressor uses the full opcode space (M1a, M1b, M2 offset reuse, M2 lengths
// 5-8, trailing literal encoding, M4 large offsets). These tests verify the Go
// decompressor correctly handles ALL opcodes by decompressing data produced by
// the real liblzo2 C library.
//
// Test vectors are generated by testdata/gen/gen_vectors.c using liblzo2 2.10.
// Regenerate: cd testdata/gen && docker build -t lzo1z-gen . && docker run --rm lzo1z-gen > ../../interop_vectors_test.go

import (
	"bytes"
	"testing"
)

func TestDecompressCInterop(t *testing.T) {
	for _, tc := range interopTestCases {
		t.Run(tc.name, func(t *testing.T) {
			if tc.inputLen == 0 {
				return // skip empty
			}

			// Decompress the C-compressed data
			out := make([]byte, tc.inputLen+100)
			n, err := Decompress(tc.compressed, out)
			if err != nil {
				t.Fatalf("Decompress failed: %v", err)
			}

			if n != tc.inputLen {
				t.Fatalf("Decompress returned %d bytes, want %d", n, tc.inputLen)
			}

			if !bytes.Equal(out[:n], tc.input) {
				// Find first difference
				for i := 0; i < n && i < len(tc.input); i++ {
					if out[i] != tc.input[i] {
						t.Fatalf("Mismatch at byte %d: got 0x%02x, want 0x%02x", i, out[i], tc.input[i])
					}
				}
				t.Fatalf("Output length mismatch")
			}
		})
	}
}

func TestDecompressCInteropRoundtrip(t *testing.T) {
	// For each C-compressed vector, verify that our Go compressor can also
	// compress the input and that both the Go-compressed and C-compressed
	// versions decompress to the same output.
	for _, tc := range interopTestCases {
		t.Run(tc.name, func(t *testing.T) {
			if tc.inputLen == 0 {
				return
			}

			// Go compress
			goDst := make([]byte, MaxCompressedSize(tc.inputLen))
			goN, err := Compress(tc.input, goDst)
			if err != nil {
				t.Fatalf("Go Compress failed: %v", err)
			}

			// Decompress Go-compressed
			goOut := make([]byte, tc.inputLen+100)
			goDecompN, err := Decompress(goDst[:goN], goOut)
			if err != nil {
				t.Fatalf("Decompress(Go-compressed) failed: %v", err)
			}

			// Decompress C-compressed
			cOut := make([]byte, tc.inputLen+100)
			cDecompN, err := Decompress(tc.compressed, cOut)
			if err != nil {
				t.Fatalf("Decompress(C-compressed) failed: %v", err)
			}

			// Both should produce identical output
			if !bytes.Equal(goOut[:goDecompN], cOut[:cDecompN]) {
				t.Fatalf("Go-compressed and C-compressed decompress to different output")
			}

			if !bytes.Equal(goOut[:goDecompN], tc.input) {
				t.Fatalf("Decompressed output doesn't match original input")
			}

			// Log compression ratio comparison
			t.Logf("C: %d->%d (%.1f%%), Go: %d->%d (%.1f%%)",
				tc.inputLen, len(tc.compressed), float64(len(tc.compressed))/float64(tc.inputLen)*100,
				tc.inputLen, goN, float64(goN)/float64(tc.inputLen)*100)
		})
	}
}
